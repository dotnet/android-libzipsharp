<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MustNotBeNullOrEmpty_string" xml:space="preserve">
    <value>'{0}' 不可為 Null 或空白。</value>
    <comment>{0} - The name of the parameter</comment>
  </data>
  <data name="InvalidEntryType_string_type" xml:space="preserve">
    <value>'{0}' 是 '{1}' 的執行個體，這不是有效的項目類型。預期的類型為 '{2}'。</value>
    <comment>{0} - The name of the parameter.
{1} - The expected type of the parameter.
{2} - The actual type of the parameter.</comment>
  </data>
  <data name="UnsupportedPermission_UnixExternalPermissions" xml:space="preserve">
    <value>'{0}' 不是支援的檔案類型。目前僅支援一般檔案、目錄和符號連結。</value>
    <comment>{0} - The name of the permission.</comment>
  </data>
  <data name="MustBeAnInstanceOf_string_type" xml:space="preserve">
    <value>'{0}' 必須是 '{1}' 的執行個體。</value>
    <comment>{0} - The name of the parameter.
{1} - The type the parameter should be.</comment>
  </data>
  <data name="ExpectedAnInstanceOf_string_type" xml:space="preserve">
    <value>{0}' 是 '{1}' 的執行個體，而非預期類型 '{2}'。</value>
    <comment>{0} - The expected type of the parameter.
{1} - The name of the parameter.
{2} - The actual type of the parameter.</comment>
  </data>
  <data name="UnableToDetermineFileType_file" xml:space="preserve">
    <value>無法判斷檔案 '{0}' 的類型。</value>
    <comment>{0} - A filename</comment>
  </data>
  <data name="FailedToReadSymLink_link_error" xml:space="preserve">
    <value>無法讀取符號連結 '{0}': {1}。</value>
    <comment>{0} - The symbolic link that was being read.
{1} - The actual error message reported by the operating system.</comment>
  </data>
  <data name="FileTypeNotSupported_filetype" xml:space="preserve">
    <value>不支援儲存類型 '{0}' 的檔案。</value>
    <comment>{0} - The type of the file.</comment>
  </data>
  <data name="FailedToSetOwner_entry_error_oserror" xml:space="preserve">
    <value>警告: 無法設定項目 '{0}' 的擁有者 ({1}:{2})。</value>
    <comment>{0} - A filename.
{1} - The error message.
{2} - The operating system error.</comment>
  </data>
  <data name="FailedToStatFile_file_error" xml:space="preserve">
    <value>警告: 無法統計檔案 '{0}': {1}。</value>
    <comment>{0} - A filename.
{1} - The error message.</comment>
  </data>
  <data name="UnexpectedOptionsType_string_type_type" xml:space="preserve">
    <value>'{0}' 是 '{1}' 的執行個體，這不是有效的選項類型。預期的類型為 '{2}'。</value>
    <comment>{0} - The parameter name.
{1} - The expected type of the parameter.
{2} - The actual type of the parameter.</comment>
  </data>
  <data name="FileAlreadyExists" xml:space="preserve">
    <value>檔案已存在。</value>
  </data>
  <data name="FilePathAlreadyExists_file" xml:space="preserve">
    <value>檔案 '{0}' 已經存在。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="OutOfMemory" xml:space="preserve">
    <value>libzip 失敗，因為發生記憶體不足的錯誤。</value>
    <comment>The following terms should not be translated: libzip</comment>
  </data>
  <data name="StreamFailedConsistencyChecks" xml:space="preserve">
    <value>此資料流無法一致性檢查。</value>
  </data>
  <data name="StreamDoesNotExist" xml:space="preserve">
    <value>資料流不存在，且未要求建立該檔案。</value>
  </data>
  <data name="StreamIsNotAZip" xml:space="preserve">
    <value>資料流不是 ZIP 封存。</value>
  </data>
  <data name="StreamCouldNotBeOpened" xml:space="preserve">
    <value>無法開啟資料流。</value>
  </data>
  <data name="ErrorReadingStream" xml:space="preserve">
    <value>讀取資料流時發生錯誤。</value>
  </data>
  <data name="StreamDoesNotSupportSeeking" xml:space="preserve">
    <value>此資料流不支援搜尋。</value>
  </data>
  <data name="UnexpectedLibZipError_error" xml:space="preserve">
    <value>發生未預期的 libzip 錯誤: {0}。</value>
    <comment>The following is the name of a library and should not be translated: libzip
{0} - An error message from libzip.</comment>
  </data>
  <data name="FileFailedConsistencyChecks_file" xml:space="preserve">
    <value>此檔案 {0} 無法一致性檢查。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="FileDoesNotExist_file" xml:space="preserve">
    <value>檔案 '{0}' 不存在，且未要求建立該檔案。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="FileIsNotAZip_file" xml:space="preserve">
    <value>檔案 '{0}' 不是 ZIP 封存。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="FileCouldNotBeOpened_file" xml:space="preserve">
    <value>無法開啟檔案 '{0}'。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="ErrorReadingFile_file" xml:space="preserve">
    <value>讀取檔案 '{0}' 時發生錯誤。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="FileDoesNotSupportSeeking_file" xml:space="preserve">
    <value>此檔案 '{0}' 不支援搜尋。</value>
    <comment>{0} - A filename.</comment>
  </data>
  <data name="DestinationMustNotBeEmpty" xml:space="preserve">
    <value>封存目的地路徑不得為空白。</value>
  </data>
  <data name="UnknownError" xml:space="preserve">
    <value>未知的錯誤。</value>
  </data>
</root>